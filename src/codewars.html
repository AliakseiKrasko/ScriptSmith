<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //TODO: практика решения задач по нативным javascript
    function binarySearch(sortedArray, target) {
        let left = 0;
        let right = sortedArray.length - 1;

        while (left <= right) {
            // Находим средний индекс
            const mid = Math.floor((left + right) / 2);
            const midValue = sortedArray[mid];

            if (midValue === target) {
                return mid; // Нашли элемент
            } else if (midValue < target) {
                left = mid + 1; // Ищем в правой половине
            } else {
                right = mid - 1; // Ищем в левой половине
            }
        }

        return -1; // Элемент не найден
    }

    console.log(binarySearch([11, 12, 22, 25, 34, 64, 90]))
    /*Условие задачи:
        Напишите функцию binarySearch на JavaScript, которая принимает отсортированный массив чисел и целевое значение, а возвращает индекс этого значения в массиве или -1, если значение не найдено. Используйте алгоритм бинарного поиска.

        Решение:
    javascript
    function binarySearch(sortedArray, target) {
        let left = 0;
        let right = sortedArray.length - 1;

        while (left <= right) {
            // Находим средний индекс
            const mid = Math.floor((left + right) / 2);
            const midValue = sortedArray[mid];

            if (midValue === target) {
                return mid; // Нашли элемент
            } else if (midValue < target) {
                left = mid + 1; // Ищем в правой половине
            } else {
                right = mid - 1; // Ищем в левой половине
            }
        }

        return -1; // Элемент не найден
    }

    // Пример использования:
    const sortedArray = [11, 12, 22, 25, 34, 64, 90];
    const target = 25;
    console.log(`Ищем ${target} в массиве:`, sortedArray);
    const resultIndex = binarySearch(sortedArray, target);

    if (resultIndex !== -1) {
        console.log(`Элемент найден на позиции ${resultIndex}`);
    } else {
        console.log('Элемент не найден');
    }
    Объяснение алгоритма:
        Бинарный поиск работает только на отсортированных массивах.

        Алгоритм делит массив пополам на каждой итерации:

        Находим средний элемент массива

    Если средний элемент равен целевому - возвращаем его индекс

    Если средний элемент меньше целевого - продолжаем поиск в правой половине

    Если средний элемент больше целевого - продолжаем поиск в левой половине

    Поиск продолжается, пока границы поиска (left и right) не пересекутся.

        Дополнительные варианты реализации:
        Рекурсивная версия:
        javascript
    function binarySearchRecursive(sortedArray, target, left = 0, right = sortedArray.length - 1) {
        if (left > right) return -1;

        const mid = Math.floor((left + right) / 2);
        const midValue = sortedArray[mid];

        if (midValue === target) return mid;

        return midValue < target
            ? binarySearchRecursive(sortedArray, target, mid + 1, right)
            : binarySearchRecursive(sortedArray, target, left, mid - 1);
    }
    Поиск первого вхождения (если есть дубликаты):
    javascript
    function binarySearchFirstOccurrence(sortedArray, target) {
        let left = 0;
        let right = sortedArray.length - 1;
        let result = -1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);

            if (sortedArray[mid] === target) {
                result = mid;
                right = mid - 1; // Продолжаем искать в левой части
            } else if (sortedArray[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }
    Сложность алгоритма: O(log n), так как на каждом шаге область поиска уменьшается вдвое.*/



    function bubbleSort(arr) {
        let n = arr.length;
        // Флаг для оптимизации - если за проход не было перестановок, массив отсортирован
        let swapped;

        for (let i = 0; i < n - 1; i++) {
            swapped = false;

            for (let j = 0; j < n - i - 1; j++) {
                // Сравниваем соседние элементы
                if (arr[j] > arr[j + 1]) {
                    // Меняем местами, если текущий элемент больше следующего
                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                    swapped = true;
                }
            }

            // Если перестановок не было, массив отсортирован
            if (!swapped) break;
        }

        return arr;
    }

    console.log(bubbleSort([64, 34, 25, 12, 22, 11, 90]))


    // Условие задачи:
    //     Напишите функцию bubbleSort на JavaScript, которая принимает массив чисел и возвращает отсортированный массив в порядке возрастания, используя алгоритм пузырьковой сортировки.
    //
    //     Решение:
    // javascript
    // function bubbleSort(arr) {
    //     let n = arr.length;
    //     // Флаг для оптимизации - если за проход не было перестановок, массив отсортирован
    //     let swapped;
    //
    //     for (let i = 0; i < n - 1; i++) {
    //         swapped = false;
    //
    //         for (let j = 0; j < n - i - 1; j++) {
    //             // Сравниваем соседние элементы
    //             if (arr[j] > arr[j + 1]) {
    //                 // Меняем местами, если текущий элемент больше следующего
    //                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    //                 swapped = true;
    //             }
    //         }
    //
    //         // Если перестановок не было, массив отсортирован
    //         if (!swapped) break;
    //     }
    //
    //     return arr;
    // }
    //
    // // Пример использования:
    // const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
    // console.log("Неотсортированный массив:", unsortedArray);
    // const sortedArray = bubbleSort(unsortedArray);
    // console.log("Отсортированный массив:", sortedArray);
    // Объяснение алгоритма:
    //     Пузырьковая сортировка - это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.
    //
    //     Внешний цикл for проходит по всем элементам массива.
    //
    //     Внутренний цикл for сравнивает пары соседних элементов и меняет их местами, если нужно.
    //
    //     После каждого прохода внутреннего цикла наибольший "всплывает" (как пузырек) в конец массива, поэтому на каждом следующем проходе можно проверять на один элемент меньше (отсюда n - i - 1).
    //
    // Флаг swapped оптимизирует алгоритм - если за весь проход не было ни одной перестановки, массив уже отсортирован и можно завершить работу.
    //
    //     Сложность алгоритма:
    //
    //     Худший случай: O(n²)
    //
    // Лучший случай (для оптимизированной версии): O(n)



</script>
</body>
</html>